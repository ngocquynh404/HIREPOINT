{"version":3,"sources":["../../../src/generated/compose/ColumnTransformer.ts","../../../src/generated/compose/TransformedTargetRegressor.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Applies transformers to columns of an array or pandas DataFrame.\n\n  This estimator allows different columns or column subsets of the input to be transformed separately and the features generated by each transformer will be concatenated to form a single feature space. This is useful for heterogeneous or columnar data, to combine several feature extraction mechanisms or transformations into a single transformer.\n\n  Read more in the [User Guide](https://scikit-learn.org/stable/modules/generated/../compose.html#column-transformer).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.compose.ColumnTransformer.html)\n */\nexport class ColumnTransformer {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      List of (name, transformer, columns) tuples specifying the transformer objects to be applied to subsets of the data.\n     */\n    transformers?: any\n\n    /**\n      By default, only the specified columns in `transformers` are transformed and combined in the output, and the non-specified columns are dropped. (default of `'drop'`). By specifying `remainder='passthrough'`, all remaining columns that were not specified in `transformers`, but present in the data passed to `fit` will be automatically passed through. This subset of columns is concatenated with the output of the transformers. For dataframes, extra columns not seen during `fit` will be excluded from the output of `transform`. By setting `remainder` to be an estimator, the remaining non-specified columns will use the `remainder` estimator. The estimator must support [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit) and [transform](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-transform). Note that using this feature requires that the DataFrame columns input at [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit) and [transform](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-transform) have identical order.\n\n      @defaultValue `'drop'`\n     */\n    remainder?: 'drop' | 'passthrough'\n\n    /**\n      If the output of the different transformers contains sparse matrices, these will be stacked as a sparse matrix if the overall density is lower than this value. Use `sparse_threshold=0` to always return dense. When the transformed output consists of all dense data, the stacked result will be dense, and this keyword will be ignored.\n\n      @defaultValue `0.3`\n     */\n    sparse_threshold?: number\n\n    /**\n      Number of jobs to run in parallel. `undefined` means 1 unless in a [`joblib.parallel_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.5.dev0)\") context. `\\-1` means using all processors. See [Glossary](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Multiplicative weights for features per transformer. The output of the transformer is multiplied by these weights. Keys are transformer names, values the weights.\n     */\n    transformer_weights?: any\n\n    /**\n      If `true`, the time elapsed while fitting each transformer will be printed as it is completed.\n\n      @defaultValue `false`\n     */\n    verbose?: boolean\n\n    /**\n      If `true`, [`ColumnTransformer.get_feature_names_out`](https://scikit-learn.org/stable/modules/generated/#sklearn.compose.ColumnTransformer.get_feature_names_out \"sklearn.compose.ColumnTransformer.get_feature_names_out\") will prefix all feature names with the name of the transformer that generated that feature. If `false`, [`ColumnTransformer.get_feature_names_out`](https://scikit-learn.org/stable/modules/generated/#sklearn.compose.ColumnTransformer.get_feature_names_out \"sklearn.compose.ColumnTransformer.get_feature_names_out\") will not prefix any feature names and will error if feature names are not unique.\n\n      @defaultValue `true`\n     */\n    verbose_feature_names_out?: boolean\n\n    /**\n      Force the columns of the last entry of `transformers_`, which corresponds to the “remainder” transformer, to always be stored as indices (int) rather than column names (str). See description of the `transformers_` attribute for details.\n\n      @defaultValue `true`\n     */\n    force_int_remainder_cols?: boolean\n  }) {\n    this.id = `ColumnTransformer${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ColumnTransformer instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error('ColumnTransformer.init requires a PythonBridge instance')\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.compose import ColumnTransformer\ntry: bridgeColumnTransformer\nexcept NameError: bridgeColumnTransformer = {}\n`\n\n    // set up constructor params\n    await this._py\n      .ex`ctor_ColumnTransformer = {'transformers': ${this.opts['transformers'] ?? undefined}, 'remainder': ${this.opts['remainder'] ?? undefined}, 'sparse_threshold': ${this.opts['sparse_threshold'] ?? undefined}, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'transformer_weights': ${this.opts['transformer_weights'] ?? undefined}, 'verbose': ${this.opts['verbose'] ?? undefined}, 'verbose_feature_names_out': ${this.opts['verbose_feature_names_out'] ?? undefined}, 'force_int_remainder_cols': ${this.opts['force_int_remainder_cols'] ?? undefined}}\n\nctor_ColumnTransformer = {k: v for k, v in ctor_ColumnTransformer.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeColumnTransformer[${this.id}] = ColumnTransformer(**ctor_ColumnTransformer)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeColumnTransformer[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit all transformers using X.\n   */\n  async fit(opts: {\n    /**\n      Input data, of which specified subsets are used to fit the transformers.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Targets for supervised learning.\n     */\n    y?: ArrayLike[]\n\n    /**\n      Parameters to be passed to the underlying transformers’ `fit` and `transform` methods.\n\n      You can only pass this if metadata routing is enabled, which you can enable using `sklearn.set_config(enable_metadata_routing=`true`)`.\n     */\n    params?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ColumnTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ColumnTransformer must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_ColumnTransformer_fit = {'X': np.array(${opts['X'] ?? undefined}) if ${opts['X'] !== undefined} else None, 'y': np.array(${opts['y'] ?? undefined}) if ${opts['y'] !== undefined} else None, 'params': ${opts['params'] ?? undefined}}\n\npms_ColumnTransformer_fit = {k: v for k, v in pms_ColumnTransformer_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ColumnTransformer_fit = bridgeColumnTransformer[${this.id}].fit(**pms_ColumnTransformer_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ColumnTransformer_fit.tolist() if hasattr(res_ColumnTransformer_fit, 'tolist') else res_ColumnTransformer_fit`\n  }\n\n  /**\n    Fit all transformers, transform the data and concatenate results.\n   */\n  async fit_transform(opts: {\n    /**\n      Input data, of which specified subsets are used to fit the transformers.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Targets for supervised learning.\n     */\n    y?: ArrayLike\n\n    /**\n      Parameters to be passed to the underlying transformers’ `fit` and `transform` methods.\n\n      You can only pass this if metadata routing is enabled, which you can enable using `sklearn.set_config(enable_metadata_routing=`true`)`.\n     */\n    params?: any\n  }): Promise<ArrayLike | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ColumnTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ColumnTransformer must call init() before fit_transform()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_ColumnTransformer_fit_transform = {'X': np.array(${opts['X'] ?? undefined}) if ${opts['X'] !== undefined} else None, 'y': np.array(${opts['y'] ?? undefined}) if ${opts['y'] !== undefined} else None, 'params': ${opts['params'] ?? undefined}}\n\npms_ColumnTransformer_fit_transform = {k: v for k, v in pms_ColumnTransformer_fit_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ColumnTransformer_fit_transform = bridgeColumnTransformer[${this.id}].fit_transform(**pms_ColumnTransformer_fit_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ColumnTransformer_fit_transform.tolist() if hasattr(res_ColumnTransformer_fit_transform, 'tolist') else res_ColumnTransformer_fit_transform`\n  }\n\n  /**\n    Get output feature names for transformation.\n   */\n  async get_feature_names_out(opts: {\n    /**\n      Input features.\n     */\n    input_features?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ColumnTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ColumnTransformer must call init() before get_feature_names_out()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_ColumnTransformer_get_feature_names_out = {'input_features': ${opts['input_features'] ?? undefined}}\n\npms_ColumnTransformer_get_feature_names_out = {k: v for k, v in pms_ColumnTransformer_get_feature_names_out.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ColumnTransformer_get_feature_names_out = bridgeColumnTransformer[${this.id}].get_feature_names_out(**pms_ColumnTransformer_get_feature_names_out)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ColumnTransformer_get_feature_names_out.tolist() if hasattr(res_ColumnTransformer_get_feature_names_out, 'tolist') else res_ColumnTransformer_get_feature_names_out`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRouter`](https://scikit-learn.org/stable/modules/generated/sklearn.utils.metadata_routing.MetadataRouter.html#sklearn.utils.metadata_routing.MetadataRouter \"sklearn.utils.metadata_routing.MetadataRouter\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ColumnTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ColumnTransformer must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_ColumnTransformer_get_metadata_routing = {'routing': ${opts['routing'] ?? undefined}}\n\npms_ColumnTransformer_get_metadata_routing = {k: v for k, v in pms_ColumnTransformer_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ColumnTransformer_get_metadata_routing = bridgeColumnTransformer[${this.id}].get_metadata_routing(**pms_ColumnTransformer_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ColumnTransformer_get_metadata_routing.tolist() if hasattr(res_ColumnTransformer_get_metadata_routing, 'tolist') else res_ColumnTransformer_get_metadata_routing`\n  }\n\n  /**\n    Set the output container when `\"transform\"` and `\"fit_transform\"` are called.\n\n    Calling `set_output` will set the output of all estimators in `transformers` and `transformers_`.\n   */\n  async set_output(opts: {\n    /**\n      Configure output of `transform` and `fit_transform`.\n     */\n    transform?: 'default' | 'pandas' | 'polars'\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ColumnTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ColumnTransformer must call init() before set_output()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_ColumnTransformer_set_output = {'transform': ${opts['transform'] ?? undefined}}\n\npms_ColumnTransformer_set_output = {k: v for k, v in pms_ColumnTransformer_set_output.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ColumnTransformer_set_output = bridgeColumnTransformer[${this.id}].set_output(**pms_ColumnTransformer_set_output)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ColumnTransformer_set_output.tolist() if hasattr(res_ColumnTransformer_set_output, 'tolist') else res_ColumnTransformer_set_output`\n  }\n\n  /**\n    Transform X separately by each transformer, concatenate results.\n   */\n  async transform(opts: {\n    /**\n      The data to be transformed by subset.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Parameters to be passed to the underlying transformers’ `transform` method.\n\n      You can only pass this if metadata routing is enabled, which you can enable using `sklearn.set_config(enable_metadata_routing=`true`)`.\n     */\n    params?: any\n  }): Promise<ArrayLike | SparseMatrix[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ColumnTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('ColumnTransformer must call init() before transform()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_ColumnTransformer_transform = {'X': np.array(${opts['X'] ?? undefined}) if ${opts['X'] !== undefined} else None, 'params': ${opts['params'] ?? undefined}}\n\npms_ColumnTransformer_transform = {k: v for k, v in pms_ColumnTransformer_transform.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_ColumnTransformer_transform = bridgeColumnTransformer[${this.id}].transform(**pms_ColumnTransformer_transform)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_ColumnTransformer_transform.tolist() if hasattr(res_ColumnTransformer_transform, 'tolist') else res_ColumnTransformer_transform`\n  }\n\n  /**\n    The collection of fitted transformers as tuples of (name, fitted_transformer, column). `fitted_transformer` can be an estimator, or `'drop'`; `'passthrough'` is replaced with an equivalent [`FunctionTransformer`](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.FunctionTransformer.html#sklearn.preprocessing.FunctionTransformer \"sklearn.preprocessing.FunctionTransformer\"). In case there were no columns selected, this will be the unfitted transformer. If there are remaining columns, the final element is a tuple of the form: (‘remainder’, transformer, remaining_columns) corresponding to the `remainder` parameter. If there are remaining columns, then `len(transformers_)==len(transformers)+1`, otherwise `len(transformers_)==len(transformers)`.\n   */\n  get transformers_(): Promise<any[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ColumnTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ColumnTransformer must call init() before accessing transformers_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ColumnTransformer_transformers_ = bridgeColumnTransformer[${this.id}].transformers_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ColumnTransformer_transformers_.tolist() if hasattr(attr_ColumnTransformer_transformers_, 'tolist') else attr_ColumnTransformer_transformers_`\n    })()\n  }\n\n  /**\n    Boolean flag indicating whether the output of `transform` is a sparse matrix or a dense numpy array, which depends on the output of the individual transformers and the `sparse_threshold` keyword.\n   */\n  get sparse_output_(): Promise<boolean> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ColumnTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ColumnTransformer must call init() before accessing sparse_output_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ColumnTransformer_sparse_output_ = bridgeColumnTransformer[${this.id}].sparse_output_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ColumnTransformer_sparse_output_.tolist() if hasattr(attr_ColumnTransformer_sparse_output_, 'tolist') else attr_ColumnTransformer_sparse_output_`\n    })()\n  }\n\n  /**\n    A dictionary from each transformer name to a slice, where the slice corresponds to indices in the transformed output. This is useful to inspect which transformer is responsible for which transformed feature(s).\n   */\n  get output_indices_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ColumnTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ColumnTransformer must call init() before accessing output_indices_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ColumnTransformer_output_indices_ = bridgeColumnTransformer[${this.id}].output_indices_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ColumnTransformer_output_indices_.tolist() if hasattr(attr_ColumnTransformer_output_indices_, 'tolist') else attr_ColumnTransformer_output_indices_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Only defined if the underlying transformers expose such an attribute when fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ColumnTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ColumnTransformer must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ColumnTransformer_n_features_in_ = bridgeColumnTransformer[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ColumnTransformer_n_features_in_.tolist() if hasattr(attr_ColumnTransformer_n_features_in_, 'tolist') else attr_ColumnTransformer_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This ColumnTransformer instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'ColumnTransformer must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_ColumnTransformer_feature_names_in_ = bridgeColumnTransformer[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_ColumnTransformer_feature_names_in_.tolist() if hasattr(attr_ColumnTransformer_feature_names_in_, 'tolist') else attr_ColumnTransformer_feature_names_in_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Meta-estimator to regress on a transformed target.\n\n  Useful for applying a non-linear transformation to the target `y` in regression problems. This transformation can be given as a Transformer such as the [`QuantileTransformer`](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.QuantileTransformer.html#sklearn.preprocessing.QuantileTransformer \"sklearn.preprocessing.QuantileTransformer\") or as a function and its inverse such as `np.log` and `np.exp`.\n\n  The computation during [`fit`](https://scikit-learn.org/stable/modules/generated/#sklearn.compose.TransformedTargetRegressor.fit \"sklearn.compose.TransformedTargetRegressor.fit\") is:\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.compose.TransformedTargetRegressor.html)\n */\nexport class TransformedTargetRegressor {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      Regressor object such as derived from [`RegressorMixin`](https://scikit-learn.org/stable/modules/generated/sklearn.base.RegressorMixin.html#sklearn.base.RegressorMixin \"sklearn.base.RegressorMixin\"). This regressor will automatically be cloned each time prior to fitting. If `regressor is None`, [`LinearRegression`](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html#sklearn.linear_model.LinearRegression \"sklearn.linear_model.LinearRegression\") is created and used.\n     */\n    regressor?: any\n\n    /**\n      Estimator object such as derived from [`TransformerMixin`](https://scikit-learn.org/stable/modules/generated/sklearn.base.TransformerMixin.html#sklearn.base.TransformerMixin \"sklearn.base.TransformerMixin\"). Cannot be set at the same time as `func` and `inverse_func`. If `transformer is None` as well as `func` and `inverse_func`, the transformer will be an identity transformer. Note that the transformer will be cloned during fitting. Also, the transformer is restricting `y` to be a numpy array.\n     */\n    transformer?: any\n\n    /**\n      Function to apply to `y` before passing to [`fit`](https://scikit-learn.org/stable/modules/generated/#sklearn.compose.TransformedTargetRegressor.fit \"sklearn.compose.TransformedTargetRegressor.fit\"). Cannot be set at the same time as `transformer`. If `func is None`, the function used will be the identity function. If `func` is set, `inverse_func` also needs to be provided. The function needs to return a 2-dimensional array.\n     */\n    func?: any\n\n    /**\n      Function to apply to the prediction of the regressor. Cannot be set at the same time as `transformer`. The inverse function is used to return predictions to the same space of the original training labels. If `inverse_func` is set, `func` also needs to be provided. The inverse function needs to return a 2-dimensional array.\n     */\n    inverse_func?: any\n\n    /**\n      Whether to check that `transform` followed by `inverse_transform` or `func` followed by `inverse_func` leads to the original targets.\n\n      @defaultValue `true`\n     */\n    check_inverse?: boolean\n  }) {\n    this.id = `TransformedTargetRegressor${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TransformedTargetRegressor instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'TransformedTargetRegressor.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.compose import TransformedTargetRegressor\ntry: bridgeTransformedTargetRegressor\nexcept NameError: bridgeTransformedTargetRegressor = {}\n`\n\n    // set up constructor params\n    await this._py\n      .ex`ctor_TransformedTargetRegressor = {'regressor': ${this.opts['regressor'] ?? undefined}, 'transformer': ${this.opts['transformer'] ?? undefined}, 'func': ${this.opts['func'] ?? undefined}, 'inverse_func': ${this.opts['inverse_func'] ?? undefined}, 'check_inverse': ${this.opts['check_inverse'] ?? undefined}}\n\nctor_TransformedTargetRegressor = {k: v for k, v in ctor_TransformedTargetRegressor.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeTransformedTargetRegressor[${this.id}] = TransformedTargetRegressor(**ctor_TransformedTargetRegressor)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeTransformedTargetRegressor[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the model according to the given training data.\n   */\n  async fit(opts: {\n    /**\n      Training vector, where `n_samples` is the number of samples and `n_features` is the number of features.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n\n    /**\n      Parameters passed to the `fit` method of the underlying regressor.\n     */\n    fit_params?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TransformedTargetRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TransformedTargetRegressor must call init() before fit()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_TransformedTargetRegressor_fit = {'X': np.array(${opts['X'] ?? undefined}) if ${opts['X'] !== undefined} else None, 'y': np.array(${opts['y'] ?? undefined}) if ${opts['y'] !== undefined} else None, 'fit_params': ${opts['fit_params'] ?? undefined}}\n\npms_TransformedTargetRegressor_fit = {k: v for k, v in pms_TransformedTargetRegressor_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TransformedTargetRegressor_fit = bridgeTransformedTargetRegressor[${this.id}].fit(**pms_TransformedTargetRegressor_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TransformedTargetRegressor_fit.tolist() if hasattr(res_TransformedTargetRegressor_fit, 'tolist') else res_TransformedTargetRegressor_fit`\n  }\n\n  /**\n    Raise `NotImplementedError`.\n\n    This estimator does not support metadata routing yet.\n   */\n  async get_metadata_routing(opts: {}): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TransformedTargetRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TransformedTargetRegressor must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py.ex`pms_TransformedTargetRegressor_get_metadata_routing = {}\n\npms_TransformedTargetRegressor_get_metadata_routing = {k: v for k, v in pms_TransformedTargetRegressor_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TransformedTargetRegressor_get_metadata_routing = bridgeTransformedTargetRegressor[${this.id}].get_metadata_routing(**pms_TransformedTargetRegressor_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TransformedTargetRegressor_get_metadata_routing.tolist() if hasattr(res_TransformedTargetRegressor_get_metadata_routing, 'tolist') else res_TransformedTargetRegressor_get_metadata_routing`\n  }\n\n  /**\n    Predict using the base regressor, applying inverse.\n\n    The regressor is used to predict and the `inverse_func` or `inverse_transform` is applied before returning the prediction.\n   */\n  async predict(opts: {\n    /**\n      Samples.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Parameters passed to the `predict` method of the underlying regressor.\n     */\n    predict_params?: any\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TransformedTargetRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TransformedTargetRegressor must call init() before predict()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_TransformedTargetRegressor_predict = {'X': np.array(${opts['X'] ?? undefined}) if ${opts['X'] !== undefined} else None, 'predict_params': ${opts['predict_params'] ?? undefined}}\n\npms_TransformedTargetRegressor_predict = {k: v for k, v in pms_TransformedTargetRegressor_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TransformedTargetRegressor_predict = bridgeTransformedTargetRegressor[${this.id}].predict(**pms_TransformedTargetRegressor_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TransformedTargetRegressor_predict.tolist() if hasattr(res_TransformedTargetRegressor_predict, 'tolist') else res_TransformedTargetRegressor_predict`\n  }\n\n  /**\n    Return the coefficient of determination of the prediction.\n\n    The coefficient of determination \\\\(R^2\\\\) is defined as \\\\((1 - \\\\frac{u}{v})\\\\), where \\\\(u\\\\) is the residual sum of squares `((y_true \\- y_pred)\\*\\* 2).sum()` and \\\\(v\\\\) is the total sum of squares `((y_true \\- y_true.mean()) \\*\\* 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a \\\\(R^2\\\\) score of 0.0.\n   */\n  async score(opts: {\n    /**\n      Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape `(n_samples, n_samples_fitted)`, where `n_samples_fitted` is the number of samples used in the fitting for the estimator.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True values for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TransformedTargetRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TransformedTargetRegressor must call init() before score()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_TransformedTargetRegressor_score = {'X': np.array(${opts['X'] ?? undefined}) if ${opts['X'] !== undefined} else None, 'y': np.array(${opts['y'] ?? undefined}) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${opts['sample_weight'] !== undefined} else None}\n\npms_TransformedTargetRegressor_score = {k: v for k, v in pms_TransformedTargetRegressor_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TransformedTargetRegressor_score = bridgeTransformedTargetRegressor[${this.id}].score(**pms_TransformedTargetRegressor_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TransformedTargetRegressor_score.tolist() if hasattr(res_TransformedTargetRegressor_score, 'tolist') else res_TransformedTargetRegressor_score`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TransformedTargetRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TransformedTargetRegressor must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_TransformedTargetRegressor_set_score_request = {'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_TransformedTargetRegressor_set_score_request = {k: v for k, v in pms_TransformedTargetRegressor_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_TransformedTargetRegressor_set_score_request = bridgeTransformedTargetRegressor[${this.id}].set_score_request(**pms_TransformedTargetRegressor_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_TransformedTargetRegressor_set_score_request.tolist() if hasattr(res_TransformedTargetRegressor_set_score_request, 'tolist') else res_TransformedTargetRegressor_set_score_request`\n  }\n\n  /**\n    Fitted regressor.\n   */\n  get regressor_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TransformedTargetRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TransformedTargetRegressor must call init() before accessing regressor_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TransformedTargetRegressor_regressor_ = bridgeTransformedTargetRegressor[${this.id}].regressor_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TransformedTargetRegressor_regressor_.tolist() if hasattr(attr_TransformedTargetRegressor_regressor_, 'tolist') else attr_TransformedTargetRegressor_regressor_`\n    })()\n  }\n\n  /**\n    Transformer used in [`fit`](https://scikit-learn.org/stable/modules/generated/#sklearn.compose.TransformedTargetRegressor.fit \"sklearn.compose.TransformedTargetRegressor.fit\") and [`predict`](https://scikit-learn.org/stable/modules/generated/#sklearn.compose.TransformedTargetRegressor.predict \"sklearn.compose.TransformedTargetRegressor.predict\").\n   */\n  get transformer_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TransformedTargetRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TransformedTargetRegressor must call init() before accessing transformer_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TransformedTargetRegressor_transformer_ = bridgeTransformedTargetRegressor[${this.id}].transformer_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TransformedTargetRegressor_transformer_.tolist() if hasattr(attr_TransformedTargetRegressor_transformer_, 'tolist') else attr_TransformedTargetRegressor_transformer_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This TransformedTargetRegressor instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'TransformedTargetRegressor must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_TransformedTargetRegressor_feature_names_in_ = bridgeTransformedTargetRegressor[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_TransformedTargetRegressor_feature_names_in_.tolist() if hasattr(attr_TransformedTargetRegressor_feature_names_in_, 'tolist') else attr_TransformedTargetRegressor_feature_names_in_`\n    })()\n  }\n}\n"],"mappings":"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","names":["crypto"]}