{"version":3,"sources":["../../../src/generated/calibration/CalibratedClassifierCV.ts","../../../src/generated/calibration/CalibrationDisplay.ts"],"sourcesContent":["/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Probability calibration with isotonic regression or logistic regression.\n\n  This class uses cross-validation to both estimate the parameters of a classifier and subsequently calibrate a classifier. With default `ensemble=True`, for each cv split it fits a copy of the base estimator to the training subset, and calibrates it using the testing subset. For prediction, predicted probabilities are averaged across these individual calibrated classifiers. When `ensemble=False`, cross-validation is used to obtain unbiased predictions, via [`cross_val_predict`](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.cross_val_predict.html#sklearn.model_selection.cross_val_predict \"sklearn.model_selection.cross_val_predict\"), which are then used for calibration. For prediction, the base estimator, trained using all the data, is used. This is the prediction method implemented when `probabilities=True` for [`SVC`](https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html#sklearn.svm.SVC \"sklearn.svm.SVC\") and [`NuSVC`](https://scikit-learn.org/stable/modules/generated/sklearn.svm.NuSVC.html#sklearn.svm.NuSVC \"sklearn.svm.NuSVC\") estimators (see [User Guide](https://scikit-learn.org/stable/modules/generated/../svm.html#scores-probabilities) for details).\n\n  Already fitted classifiers can be calibrated via the parameter `cv=\"prefit\"`. In this case, no cross-validation is used and all provided data is used for calibration. The user has to take care manually that data for model fitting and calibration are disjoint.\n\n  The calibration is based on the [decision_function](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-decision_function) method of the `estimator` if it exists, else on [predict_proba](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-predict_proba).\n\n  Read more in the [User Guide](https://scikit-learn.org/stable/modules/generated/../calibration.html#calibration). In order to learn more on the CalibratedClassifierCV class, see the following calibration examples: [Probability calibration of classifiers](https://scikit-learn.org/stable/modules/generated/../../auto_examples/calibration/plot_calibration.html#sphx-glr-auto-examples-calibration-plot-calibration-py), [Probability Calibration curves](https://scikit-learn.org/stable/modules/generated/../../auto_examples/calibration/plot_calibration_curve.html#sphx-glr-auto-examples-calibration-plot-calibration-curve-py), and [Probability Calibration for 3-class classification](https://scikit-learn.org/stable/modules/generated/../../auto_examples/calibration/plot_calibration_multiclass.html#sphx-glr-auto-examples-calibration-plot-calibration-multiclass-py).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.calibration.CalibratedClassifierCV.html)\n */\nexport class CalibratedClassifierCV {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The classifier whose output need to be calibrated to provide more accurate `predict_proba` outputs. The default classifier is a [`LinearSVC`](https://scikit-learn.org/stable/modules/generated/sklearn.svm.LinearSVC.html#sklearn.svm.LinearSVC \"sklearn.svm.LinearSVC\").\n     */\n    estimator?: any\n\n    /**\n      The method to use for calibration. Can be ‘sigmoid’ which corresponds to Platt’s method (i.e. a logistic regression model) or ‘isotonic’ which is a non-parametric approach. It is not advised to use isotonic calibration with too few calibration samples `(<<1000)` since it tends to overfit.\n\n      @defaultValue `'sigmoid'`\n     */\n    method?: 'sigmoid' | 'isotonic'\n\n    /**\n      Determines the cross-validation splitting strategy. Possible inputs for cv are:\n     */\n    cv?: number | 'prefit'\n\n    /**\n      Number of jobs to run in parallel. `undefined` means 1 unless in a [`joblib.parallel_backend`](https://joblib.readthedocs.io/en/latest/generated/joblib.parallel_backend.html#joblib.parallel_backend \"(in joblib v1.5.dev0)\") context. `\\-1` means using all processors.\n\n      Base estimator clones are fitted in parallel across cross-validation iterations. Therefore parallelism happens only when `cv != \"prefit\"`.\n\n      See [Glossary](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-n_jobs) for more details.\n     */\n    n_jobs?: number\n\n    /**\n      Determines how the calibrator is fitted when `cv` is not `'prefit'`. Ignored if `cv='prefit'`.\n\n      If `true`, the `estimator` is fitted using training data, and calibrated using testing data, for each `cv` fold. The final estimator is an ensemble of `n_cv` fitted classifier and calibrator pairs, where `n_cv` is the number of cross-validation folds. The output is the average predicted probabilities of all pairs.\n\n      If `false`, `cv` is used to compute unbiased predictions, via [`cross_val_predict`](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.cross_val_predict.html#sklearn.model_selection.cross_val_predict \"sklearn.model_selection.cross_val_predict\"), which are then used for calibration. At prediction time, the classifier used is the `estimator` trained on all the data. Note that this method is also internally implemented in [`sklearn.svm`](https://scikit-learn.org/stable/modules/generated/../../api/sklearn.svm.html#module-sklearn.svm \"sklearn.svm\") estimators with the `probabilities=True` parameter.\n\n      @defaultValue `true`\n     */\n    ensemble?: boolean\n  }) {\n    this.id = `CalibratedClassifierCV${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibratedClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'CalibratedClassifierCV.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.calibration import CalibratedClassifierCV\ntry: bridgeCalibratedClassifierCV\nexcept NameError: bridgeCalibratedClassifierCV = {}\n`\n\n    // set up constructor params\n    await this._py\n      .ex`ctor_CalibratedClassifierCV = {'estimator': ${this.opts['estimator'] ?? undefined}, 'method': ${this.opts['method'] ?? undefined}, 'cv': ${this.opts['cv'] ?? undefined}, 'n_jobs': ${this.opts['n_jobs'] ?? undefined}, 'ensemble': ${this.opts['ensemble'] ?? undefined}}\n\nctor_CalibratedClassifierCV = {k: v for k, v in ctor_CalibratedClassifierCV.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeCalibratedClassifierCV[${this.id}] = CalibratedClassifierCV(**ctor_CalibratedClassifierCV)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeCalibratedClassifierCV[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Fit the calibrated model.\n   */\n  async fit(opts: {\n    /**\n      Training data.\n     */\n    X?: ArrayLike[]\n\n    /**\n      Target values.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights. If `undefined`, then samples are equally weighted.\n     */\n    sample_weight?: ArrayLike\n\n    /**\n      Parameters to pass to the `fit` method of the underlying classifier.\n     */\n    fit_params?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibratedClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('CalibratedClassifierCV must call init() before fit()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_CalibratedClassifierCV_fit = {'X': np.array(${opts['X'] ?? undefined}) if ${opts['X'] !== undefined} else None, 'y': np.array(${opts['y'] ?? undefined}) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${opts['sample_weight'] !== undefined} else None, 'fit_params': ${opts['fit_params'] ?? undefined}}\n\npms_CalibratedClassifierCV_fit = {k: v for k, v in pms_CalibratedClassifierCV_fit.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_CalibratedClassifierCV_fit = bridgeCalibratedClassifierCV[${this.id}].fit(**pms_CalibratedClassifierCV_fit)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_CalibratedClassifierCV_fit.tolist() if hasattr(res_CalibratedClassifierCV_fit, 'tolist') else res_CalibratedClassifierCV_fit`\n  }\n\n  /**\n    Get metadata routing of this object.\n\n    Please check [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n   */\n  async get_metadata_routing(opts: {\n    /**\n      A [`MetadataRouter`](https://scikit-learn.org/stable/modules/generated/sklearn.utils.metadata_routing.MetadataRouter.html#sklearn.utils.metadata_routing.MetadataRouter \"sklearn.utils.metadata_routing.MetadataRouter\") encapsulating routing information.\n     */\n    routing?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibratedClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'CalibratedClassifierCV must call init() before get_metadata_routing()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_CalibratedClassifierCV_get_metadata_routing = {'routing': ${opts['routing'] ?? undefined}}\n\npms_CalibratedClassifierCV_get_metadata_routing = {k: v for k, v in pms_CalibratedClassifierCV_get_metadata_routing.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_CalibratedClassifierCV_get_metadata_routing = bridgeCalibratedClassifierCV[${this.id}].get_metadata_routing(**pms_CalibratedClassifierCV_get_metadata_routing)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_CalibratedClassifierCV_get_metadata_routing.tolist() if hasattr(res_CalibratedClassifierCV_get_metadata_routing, 'tolist') else res_CalibratedClassifierCV_get_metadata_routing`\n  }\n\n  /**\n    Predict the target of new samples.\n\n    The predicted class is the class that has the highest probability, and can thus be different from the prediction of the uncalibrated classifier.\n   */\n  async predict(opts: {\n    /**\n      The samples, as accepted by `estimator.predict`.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibratedClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'CalibratedClassifierCV must call init() before predict()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_CalibratedClassifierCV_predict = {'X': np.array(${opts['X'] ?? undefined}) if ${opts['X'] !== undefined} else None}\n\npms_CalibratedClassifierCV_predict = {k: v for k, v in pms_CalibratedClassifierCV_predict.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_CalibratedClassifierCV_predict = bridgeCalibratedClassifierCV[${this.id}].predict(**pms_CalibratedClassifierCV_predict)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_CalibratedClassifierCV_predict.tolist() if hasattr(res_CalibratedClassifierCV_predict, 'tolist') else res_CalibratedClassifierCV_predict`\n  }\n\n  /**\n    Calibrated probabilities of classification.\n\n    This function returns calibrated probabilities of classification according to each class on an array of test vectors X.\n   */\n  async predict_proba(opts: {\n    /**\n      The samples, as accepted by `estimator.predict_proba`.\n     */\n    X?: ArrayLike[]\n  }): Promise<NDArray[]> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibratedClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'CalibratedClassifierCV must call init() before predict_proba()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_CalibratedClassifierCV_predict_proba = {'X': np.array(${opts['X'] ?? undefined}) if ${opts['X'] !== undefined} else None}\n\npms_CalibratedClassifierCV_predict_proba = {k: v for k, v in pms_CalibratedClassifierCV_predict_proba.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_CalibratedClassifierCV_predict_proba = bridgeCalibratedClassifierCV[${this.id}].predict_proba(**pms_CalibratedClassifierCV_predict_proba)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_CalibratedClassifierCV_predict_proba.tolist() if hasattr(res_CalibratedClassifierCV_predict_proba, 'tolist') else res_CalibratedClassifierCV_predict_proba`\n  }\n\n  /**\n    Return the mean accuracy on the given test data and labels.\n\n    In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.\n   */\n  async score(opts: {\n    /**\n      Test samples.\n     */\n    X?: ArrayLike[]\n\n    /**\n      True labels for `X`.\n     */\n    y?: ArrayLike\n\n    /**\n      Sample weights.\n     */\n    sample_weight?: ArrayLike\n  }): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibratedClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('CalibratedClassifierCV must call init() before score()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_CalibratedClassifierCV_score = {'X': np.array(${opts['X'] ?? undefined}) if ${opts['X'] !== undefined} else None, 'y': np.array(${opts['y'] ?? undefined}) if ${opts['y'] !== undefined} else None, 'sample_weight': np.array(${opts['sample_weight'] ?? undefined}) if ${opts['sample_weight'] !== undefined} else None}\n\npms_CalibratedClassifierCV_score = {k: v for k, v in pms_CalibratedClassifierCV_score.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_CalibratedClassifierCV_score = bridgeCalibratedClassifierCV[${this.id}].score(**pms_CalibratedClassifierCV_score)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_CalibratedClassifierCV_score.tolist() if hasattr(res_CalibratedClassifierCV_score, 'tolist') else res_CalibratedClassifierCV_score`\n  }\n\n  /**\n    Request metadata passed to the `fit` method.\n\n    Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_fit_request(opts: {\n    /**\n      Metadata routing for `sample_weight` parameter in `fit`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibratedClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'CalibratedClassifierCV must call init() before set_fit_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_CalibratedClassifierCV_set_fit_request = {'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_CalibratedClassifierCV_set_fit_request = {k: v for k, v in pms_CalibratedClassifierCV_set_fit_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_CalibratedClassifierCV_set_fit_request = bridgeCalibratedClassifierCV[${this.id}].set_fit_request(**pms_CalibratedClassifierCV_set_fit_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_CalibratedClassifierCV_set_fit_request.tolist() if hasattr(res_CalibratedClassifierCV_set_fit_request, 'tolist') else res_CalibratedClassifierCV_set_fit_request`\n  }\n\n  /**\n    Request metadata passed to the `score` method.\n\n    Note that this method is only relevant if `enable_metadata_routing=True` (see [`sklearn.set_config`](https://scikit-learn.org/stable/modules/generated/sklearn.set_config.html#sklearn.set_config \"sklearn.set_config\")). Please see [User Guide](https://scikit-learn.org/stable/modules/generated/../../metadata_routing.html#metadata-routing) on how the routing mechanism works.\n\n    The options for each parameter are:\n   */\n  async set_score_request(opts: {\n    /**\n      Metadata routing for `sample_weight` parameter in `score`.\n     */\n    sample_weight?: string | boolean\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibratedClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'CalibratedClassifierCV must call init() before set_score_request()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_CalibratedClassifierCV_set_score_request = {'sample_weight': ${opts['sample_weight'] ?? undefined}}\n\npms_CalibratedClassifierCV_set_score_request = {k: v for k, v in pms_CalibratedClassifierCV_set_score_request.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_CalibratedClassifierCV_set_score_request = bridgeCalibratedClassifierCV[${this.id}].set_score_request(**pms_CalibratedClassifierCV_set_score_request)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_CalibratedClassifierCV_set_score_request.tolist() if hasattr(res_CalibratedClassifierCV_set_score_request, 'tolist') else res_CalibratedClassifierCV_set_score_request`\n  }\n\n  /**\n    The class labels.\n   */\n  get classes_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibratedClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'CalibratedClassifierCV must call init() before accessing classes_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_CalibratedClassifierCV_classes_ = bridgeCalibratedClassifierCV[${this.id}].classes_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_CalibratedClassifierCV_classes_.tolist() if hasattr(attr_CalibratedClassifierCV_classes_, 'tolist') else attr_CalibratedClassifierCV_classes_`\n    })()\n  }\n\n  /**\n    Number of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.\n   */\n  get n_features_in_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibratedClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'CalibratedClassifierCV must call init() before accessing n_features_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_CalibratedClassifierCV_n_features_in_ = bridgeCalibratedClassifierCV[${this.id}].n_features_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_CalibratedClassifierCV_n_features_in_.tolist() if hasattr(attr_CalibratedClassifierCV_n_features_in_, 'tolist') else attr_CalibratedClassifierCV_n_features_in_`\n    })()\n  }\n\n  /**\n    Names of features seen during [fit](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-fit). Only defined if the underlying estimator exposes such an attribute when fit.\n   */\n  get feature_names_in_(): Promise<NDArray> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibratedClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'CalibratedClassifierCV must call init() before accessing feature_names_in_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_CalibratedClassifierCV_feature_names_in_ = bridgeCalibratedClassifierCV[${this.id}].feature_names_in_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_CalibratedClassifierCV_feature_names_in_.tolist() if hasattr(attr_CalibratedClassifierCV_feature_names_in_, 'tolist') else attr_CalibratedClassifierCV_feature_names_in_`\n    })()\n  }\n\n  /**\n    The list of classifier and calibrator pairs.\n   */\n  get calibrated_classifiers_(): Promise<number> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibratedClassifierCV instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'CalibratedClassifierCV must call init() before accessing calibrated_classifiers_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_CalibratedClassifierCV_calibrated_classifiers_ = bridgeCalibratedClassifierCV[${this.id}].calibrated_classifiers_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_CalibratedClassifierCV_calibrated_classifiers_.tolist() if hasattr(attr_CalibratedClassifierCV_calibrated_classifiers_, 'tolist') else attr_CalibratedClassifierCV_calibrated_classifiers_`\n    })()\n  }\n}\n","/* eslint-disable */\n/* NOTE: This file is auto-generated. Do not edit it directly. */\n\nimport crypto from 'node:crypto'\n\nimport { PythonBridge, NDArray, ArrayLike, SparseMatrix } from '@/sklearn/types'\n\n/**\n  Calibration curve (also known as reliability diagram) visualization.\n\n  It is recommended to use [`from_estimator`](https://scikit-learn.org/stable/modules/generated/#sklearn.calibration.CalibrationDisplay.from_estimator \"sklearn.calibration.CalibrationDisplay.from_estimator\") or [`from_predictions`](https://scikit-learn.org/stable/modules/generated/#sklearn.calibration.CalibrationDisplay.from_predictions \"sklearn.calibration.CalibrationDisplay.from_predictions\") to create a `CalibrationDisplay`. All parameters are stored as attributes.\n\n  Read more about calibration in the [User Guide](https://scikit-learn.org/stable/modules/generated/../calibration.html#calibration) and more about the scikit-learn visualization API in [Visualizations](https://scikit-learn.org/stable/modules/generated/../../visualizations.html#visualizations).\n\n  For an example on how to use the visualization, see [Probability Calibration curves](https://scikit-learn.org/stable/modules/generated/../../auto_examples/calibration/plot_calibration_curve.html#sphx-glr-auto-examples-calibration-plot-calibration-curve-py).\n\n  [Python Reference](https://scikit-learn.org/stable/modules/generated/sklearn.calibration.CalibrationDisplay.html)\n */\nexport class CalibrationDisplay {\n  id: string\n  opts: any\n\n  _py: PythonBridge\n  _isInitialized: boolean = false\n  _isDisposed: boolean = false\n\n  constructor(opts?: {\n    /**\n      The proportion of samples whose class is the positive class (fraction of positives), in each bin.\n     */\n    prob_true?: NDArray\n\n    /**\n      The mean predicted probability in each bin.\n     */\n    prob_pred?: NDArray\n\n    /**\n      Probability estimates for the positive class, for each sample.\n     */\n    y_prob?: NDArray\n\n    /**\n      Name of estimator. If `undefined`, the estimator name is not shown.\n     */\n    estimator_name?: string\n\n    /**\n      The positive class when computing the calibration curve. By default, `pos_label` is set to `estimators.classes_\\[1\\]` when using `from_estimator` and set to 1 when using `from_predictions`.\n     */\n    pos_label?: number | boolean | string\n  }) {\n    this.id = `CalibrationDisplay${crypto.randomUUID().split('-')[0]}`\n    this.opts = opts || {}\n  }\n\n  get py(): PythonBridge {\n    return this._py\n  }\n\n  set py(pythonBridge: PythonBridge) {\n    this._py = pythonBridge\n  }\n\n  /**\n    Initializes the underlying Python resources.\n\n    This instance is not usable until the `Promise` returned by `init()` resolves.\n   */\n  async init(py: PythonBridge): Promise<void> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibrationDisplay instance has already been disposed'\n      )\n    }\n\n    if (this._isInitialized) {\n      return\n    }\n\n    if (!py) {\n      throw new Error(\n        'CalibrationDisplay.init requires a PythonBridge instance'\n      )\n    }\n\n    this._py = py\n\n    await this._py.ex`\nimport numpy as np\nfrom sklearn.calibration import CalibrationDisplay\ntry: bridgeCalibrationDisplay\nexcept NameError: bridgeCalibrationDisplay = {}\n`\n\n    // set up constructor params\n    await this._py\n      .ex`ctor_CalibrationDisplay = {'prob_true': np.array(${this.opts['prob_true'] ?? undefined}) if ${this.opts['prob_true'] !== undefined} else None, 'prob_pred': np.array(${this.opts['prob_pred'] ?? undefined}) if ${this.opts['prob_pred'] !== undefined} else None, 'y_prob': np.array(${this.opts['y_prob'] ?? undefined}) if ${this.opts['y_prob'] !== undefined} else None, 'estimator_name': ${this.opts['estimator_name'] ?? undefined}, 'pos_label': ${this.opts['pos_label'] ?? undefined}}\n\nctor_CalibrationDisplay = {k: v for k, v in ctor_CalibrationDisplay.items() if v is not None}`\n\n    await this._py\n      .ex`bridgeCalibrationDisplay[${this.id}] = CalibrationDisplay(**ctor_CalibrationDisplay)`\n\n    this._isInitialized = true\n  }\n\n  /**\n    Disposes of the underlying Python resources.\n\n    Once `dispose()` is called, the instance is no longer usable.\n   */\n  async dispose() {\n    if (this._isDisposed) {\n      return\n    }\n\n    if (!this._isInitialized) {\n      return\n    }\n\n    await this._py.ex`del bridgeCalibrationDisplay[${this.id}]`\n\n    this._isDisposed = true\n  }\n\n  /**\n    Plot calibration curve using a binary classifier and data.\n\n    A calibration curve, also known as a reliability diagram, uses inputs from a binary classifier and plots the average predicted probability for each bin against the fraction of positive classes, on the y-axis.\n\n    Extra keyword arguments will be passed to [`matplotlib.pyplot.plot`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot \"(in Matplotlib v3.9.2)\").\n\n    Read more about calibration in the [User Guide](https://scikit-learn.org/stable/modules/generated/../calibration.html#calibration) and more about the scikit-learn visualization API in [Visualizations](https://scikit-learn.org/stable/modules/generated/../../visualizations.html#visualizations).\n   */\n  async from_estimator(opts: {\n    /**\n      Fitted classifier or a fitted [`Pipeline`](https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline \"sklearn.pipeline.Pipeline\") in which the last estimator is a classifier. The classifier must have a [predict_proba](https://scikit-learn.org/stable/modules/generated/../../glossary.html#term-predict_proba) method.\n     */\n    estimator?: any\n\n    /**\n      Input values.\n     */\n    X?: ArrayLike | SparseMatrix[]\n\n    /**\n      Binary target values.\n     */\n    y?: ArrayLike\n\n    /**\n      Number of bins to discretize the \\[0, 1\\] interval into when calculating the calibration curve. A bigger number requires more data.\n\n      @defaultValue `5`\n     */\n    n_bins?: number\n\n    /**\n      Strategy used to define the widths of the bins.\n\n      @defaultValue `'uniform'`\n     */\n    strategy?: 'uniform' | 'quantile'\n\n    /**\n      The positive class when computing the calibration curve. By default, `estimators.classes_\\[1\\]` is considered as the positive class.\n     */\n    pos_label?: number | boolean | string\n\n    /**\n      Name for labeling curve. If `undefined`, the name of the estimator is used.\n     */\n    name?: string\n\n    /**\n      If `true`, plots a reference line representing a perfectly calibrated classifier.\n\n      @defaultValue `true`\n     */\n    ref_line?: boolean\n\n    /**\n      Axes object to plot on. If `undefined`, a new figure and axes is created.\n     */\n    ax?: any\n\n    /**\n      Keyword arguments to be passed to [`matplotlib.pyplot.plot`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot \"(in Matplotlib v3.9.2)\").\n     */\n    kwargs?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibrationDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'CalibrationDisplay must call init() before from_estimator()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_CalibrationDisplay_from_estimator = {'estimator': ${opts['estimator'] ?? undefined}, 'X': np.array(${opts['X'] ?? undefined}) if ${opts['X'] !== undefined} else None, 'y': np.array(${opts['y'] ?? undefined}) if ${opts['y'] !== undefined} else None, 'n_bins': ${opts['n_bins'] ?? undefined}, 'strategy': ${opts['strategy'] ?? undefined}, 'pos_label': ${opts['pos_label'] ?? undefined}, 'name': ${opts['name'] ?? undefined}, 'ref_line': ${opts['ref_line'] ?? undefined}, 'ax': ${opts['ax'] ?? undefined}, 'kwargs': ${opts['kwargs'] ?? undefined}}\n\npms_CalibrationDisplay_from_estimator = {k: v for k, v in pms_CalibrationDisplay_from_estimator.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_CalibrationDisplay_from_estimator = bridgeCalibrationDisplay[${this.id}].from_estimator(**pms_CalibrationDisplay_from_estimator)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_CalibrationDisplay_from_estimator.tolist() if hasattr(res_CalibrationDisplay_from_estimator, 'tolist') else res_CalibrationDisplay_from_estimator`\n  }\n\n  /**\n    Plot calibration curve using true labels and predicted probabilities.\n\n    Calibration curve, also known as reliability diagram, uses inputs from a binary classifier and plots the average predicted probability for each bin against the fraction of positive classes, on the y-axis.\n\n    Extra keyword arguments will be passed to [`matplotlib.pyplot.plot`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot \"(in Matplotlib v3.9.2)\").\n\n    Read more about calibration in the [User Guide](https://scikit-learn.org/stable/modules/generated/../calibration.html#calibration) and more about the scikit-learn visualization API in [Visualizations](https://scikit-learn.org/stable/modules/generated/../../visualizations.html#visualizations).\n   */\n  async from_predictions(opts: {\n    /**\n      True labels.\n     */\n    y_true?: ArrayLike\n\n    /**\n      The predicted probabilities of the positive class.\n     */\n    y_prob?: ArrayLike\n\n    /**\n      Number of bins to discretize the \\[0, 1\\] interval into when calculating the calibration curve. A bigger number requires more data.\n\n      @defaultValue `5`\n     */\n    n_bins?: number\n\n    /**\n      Strategy used to define the widths of the bins.\n\n      @defaultValue `'uniform'`\n     */\n    strategy?: 'uniform' | 'quantile'\n\n    /**\n      The positive class when computing the calibration curve. By default `pos_label` is set to 1.\n     */\n    pos_label?: number | boolean | string\n\n    /**\n      Name for labeling curve.\n     */\n    name?: string\n\n    /**\n      If `true`, plots a reference line representing a perfectly calibrated classifier.\n\n      @defaultValue `true`\n     */\n    ref_line?: boolean\n\n    /**\n      Axes object to plot on. If `undefined`, a new figure and axes is created.\n     */\n    ax?: any\n\n    /**\n      Keyword arguments to be passed to [`matplotlib.pyplot.plot`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot \"(in Matplotlib v3.9.2)\").\n     */\n    kwargs?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibrationDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'CalibrationDisplay must call init() before from_predictions()'\n      )\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_CalibrationDisplay_from_predictions = {'y_true': np.array(${opts['y_true'] ?? undefined}) if ${opts['y_true'] !== undefined} else None, 'y_prob': np.array(${opts['y_prob'] ?? undefined}) if ${opts['y_prob'] !== undefined} else None, 'n_bins': ${opts['n_bins'] ?? undefined}, 'strategy': ${opts['strategy'] ?? undefined}, 'pos_label': ${opts['pos_label'] ?? undefined}, 'name': ${opts['name'] ?? undefined}, 'ref_line': ${opts['ref_line'] ?? undefined}, 'ax': ${opts['ax'] ?? undefined}, 'kwargs': ${opts['kwargs'] ?? undefined}}\n\npms_CalibrationDisplay_from_predictions = {k: v for k, v in pms_CalibrationDisplay_from_predictions.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_CalibrationDisplay_from_predictions = bridgeCalibrationDisplay[${this.id}].from_predictions(**pms_CalibrationDisplay_from_predictions)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_CalibrationDisplay_from_predictions.tolist() if hasattr(res_CalibrationDisplay_from_predictions, 'tolist') else res_CalibrationDisplay_from_predictions`\n  }\n\n  /**\n    Plot visualization.\n\n    Extra keyword arguments will be passed to [`matplotlib.pyplot.plot`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot \"(in Matplotlib v3.9.2)\").\n   */\n  async plot(opts: {\n    /**\n      Axes object to plot on. If `undefined`, a new figure and axes is created.\n     */\n    ax?: any\n\n    /**\n      Name for labeling curve. If `undefined`, use `estimator_name` if not `undefined`, otherwise no labeling is shown.\n     */\n    name?: string\n\n    /**\n      If `true`, plots a reference line representing a perfectly calibrated classifier.\n\n      @defaultValue `true`\n     */\n    ref_line?: boolean\n\n    /**\n      Keyword arguments to be passed to [`matplotlib.pyplot.plot`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot \"(in Matplotlib v3.9.2)\").\n     */\n    kwargs?: any\n  }): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibrationDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error('CalibrationDisplay must call init() before plot()')\n    }\n\n    // set up method params\n    await this._py\n      .ex`pms_CalibrationDisplay_plot = {'ax': ${opts['ax'] ?? undefined}, 'name': ${opts['name'] ?? undefined}, 'ref_line': ${opts['ref_line'] ?? undefined}, 'kwargs': ${opts['kwargs'] ?? undefined}}\n\npms_CalibrationDisplay_plot = {k: v for k, v in pms_CalibrationDisplay_plot.items() if v is not None}`\n\n    // invoke method\n    await this._py\n      .ex`res_CalibrationDisplay_plot = bridgeCalibrationDisplay[${this.id}].plot(**pms_CalibrationDisplay_plot)`\n\n    // convert the result from python to node.js\n    return this\n      ._py`res_CalibrationDisplay_plot.tolist() if hasattr(res_CalibrationDisplay_plot, 'tolist') else res_CalibrationDisplay_plot`\n  }\n\n  /**\n    Calibration curve.\n   */\n  get line_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibrationDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'CalibrationDisplay must call init() before accessing line_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_CalibrationDisplay_line_ = bridgeCalibrationDisplay[${this.id}].line_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_CalibrationDisplay_line_.tolist() if hasattr(attr_CalibrationDisplay_line_, 'tolist') else attr_CalibrationDisplay_line_`\n    })()\n  }\n\n  /**\n    Axes with calibration curve.\n   */\n  get ax_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibrationDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'CalibrationDisplay must call init() before accessing ax_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_CalibrationDisplay_ax_ = bridgeCalibrationDisplay[${this.id}].ax_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_CalibrationDisplay_ax_.tolist() if hasattr(attr_CalibrationDisplay_ax_, 'tolist') else attr_CalibrationDisplay_ax_`\n    })()\n  }\n\n  /**\n    Figure containing the curve.\n   */\n  get figure_(): Promise<any> {\n    if (this._isDisposed) {\n      throw new Error(\n        'This CalibrationDisplay instance has already been disposed'\n      )\n    }\n\n    if (!this._isInitialized) {\n      throw new Error(\n        'CalibrationDisplay must call init() before accessing figure_'\n      )\n    }\n\n    return (async () => {\n      // invoke accessor\n      await this._py\n        .ex`attr_CalibrationDisplay_figure_ = bridgeCalibrationDisplay[${this.id}].figure_`\n\n      // convert the result from python to node.js\n      return this\n        ._py`attr_CalibrationDisplay_figure_.tolist() if hasattr(attr_CalibrationDisplay_figure_, 'tolist') else attr_CalibrationDisplay_figure_`\n    })()\n  }\n}\n"],"mappings":"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","names":["crypto"]}